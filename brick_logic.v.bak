module brick_logic #(
    parameter SCREEN_WIDTH  = 640,
    parameter SCREEN_HEIGHT = 480,
    parameter BRICK_ROWS    = 5,
    parameter BRICK_COLS    = 10,
    parameter BRICK_WIDTH   = 64,
    parameter BRICK_HEIGHT  = 16,
    parameter BALL_SIZE     = 6
)(
    input  wire        clk,
    input  wire        rst,
    input  wire [9:0]  ball_x,
    input  wire [9:0]  ball_y,
    input  wire signed [3:0] ball_dx,
    input  wire signed [3:0] ball_dy,
    output reg  [BRICK_ROWS*BRICK_COLS-1:0] brick_state,
    output reg  signed [3:0] new_dx,
    output reg  signed [3:0] new_dy
);

    integer row, col;
    reg collision;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            brick_state <= {BRICK_ROWS*BRICK_COLS{1'b1}}; // all bricks alive
            new_dx <= ball_dx;
            new_dy <= ball_dy;
        end else begin
            collision = 0;
            new_dx = ball_dx;
            new_dy = ball_dy;

            for (row = 0; row < BRICK_ROWS; row = row + 1) begin
                for (col = 0; col < BRICK_COLS; col = col + 1) begin
                    if (brick_state[row*BRICK_COLS + col]) begin
                        integer bx = col * BRICK_WIDTH;
                        integer by = row * BRICK_HEIGHT;

                        if ((ball_x + BALL_SIZE >= bx) && (ball_x <= bx + BRICK_WIDTH) &&
                            (ball_y + BALL_SIZE >= by) && (ball_y <= by + BRICK_HEIGHT)) begin
                            brick_state[row*BRICK_COLS + col] <= 0; // destroy brick
                            new_dy <= -ball_dy; // bounce vertically
                            collision = 1;
                        end
                    end
                end
            end
        end
    end
endmodule